
// <STF_mem_check> -*- C++ -*-

/**
 * \brief  This tool check if misaligned access; Read after Write;
 *
 */

#include <iostream>
#include <string>
#include <cstdint>
#include <iomanip>

#include "command_line_parser.hpp"
#include "stf_decoder.hpp"
#include "stf_inst_reader.hpp"
#include "stf_writer.hpp"
#include "stf_pte.hpp"
#include "stf_kernel_code_tracer.hpp"
#include "stf_filter_evt.hpp"
#include "tools_util.hpp"

static STFFilterConfig parse_command_line (int argc, char **argv) {
    // Parse options
    STFFilterConfig config;
    trace_tools::CommandLineParser parser("stf_filter_evt");
    parser.addFlag('s', "N", "start trace event filtering at N-th instruction");
    parser.addFlag('e', "M", "end trace event filtering at M-th instruction");
    parser.addMultiFlag('E', "evt", "Event to filter, i.e. -E 0x5 -E 0x2");
    parser.addFlag('K', "filter all kernel activities, not including syscalls");
    parser.addFlag('S', "filter all syscalls, keeping the call instructions");
    parser.addFlag('o', "trace", "output filename. stdout is default");
    parser.addFlag('v', "verbose mode to show message");
    parser.addPositionalArgument("trace", "trace in STF format");
    parser.parseArguments(argc, argv);

    config.verbose = parser.hasArgument('v');
    config.filterKernel = parser.hasArgument('K');
    config.filterSyscalls = parser.hasArgument('S');
    parser.getArgumentValue('e', config.endInst);
    parser.getArgumentValue('s', config.startInst);
    for(const auto& evt: parser.getMultipleValueArgument('E')) {
        config.eset.insert(parseHex<uint32_t>(evt));
    }

    parser.getArgumentValue('o', config.output_filename);
    parser.getPositionalArgument(0, config.trace_filename);

    if (config.endInst < config.startInst) {
        config.endInst = config.startInst + 1;
    }

    return config;
}



int main (int argc, char **argv)
{
    try {
        const auto config = parse_command_line (argc, argv);

        stf::KernelCodeTracer kernel_tracer(config.trace_filename, config.startInst, config.endInst);
        // kernel_tracer.Print(true);

        // Open stf trace reader
        stf::STFInstReader stf_reader(config.trace_filename);
        /* FIXME Because we have not kept up with STF versioning, this is currently broken and must be loosened.
        if (!stf_reader.checkVersion()) {
            exit(1);
        }
        */

        stf::STFWriter stf_writer(config.output_filename);
        if (!stf_writer) {
            std::cerr << "Error: Failed to open output " << config.output_filename << std::endl;
            exit(-1);
        }

        STFEventFilter filter(stf_reader);
        stf_reader.copyHeader(stf_writer);
        stf_writer.addTraceInfo(stf::STF_GEN::STF_GEN_STF_FILTER_EVT,
                                TRACE_TOOLS_VERSION_MAJOR,
                                TRACE_TOOLS_VERSION_MINOR,
                                TRACE_TOOLS_VERSION_MINOR_MINOR,
                                "Merge trace generated by stf_filter_evt");
        stf_writer.finalizeHeader();
        stf::STFRegState regState(stf_reader.getISA(), stf_reader.getInitialIEM());

        bool instFiltered = false;
        bool evtFiltered = false;
        bool reg_state_written = false;

        for (const auto& inst: stf_reader) {
            evtFiltered = false;
            if (!inst.valid()) {
                std::cerr << "ERROR: " << inst.index() << " invalid instruction ";
                stf::format_utils::formatHex(std::cerr, inst.opcode());
                std::cerr << " PC ";
                stf::format_utils::formatHex(std::cerr, inst.pc());
                std::cerr << std::endl;
            }
            // if there is register state dump; update them;
            for(const auto& state: inst.getRegisterStates()) {
                regState.regStateUpdate(state.getRecord());
            }

            if (inst.index() < config.startInst) {
                for(const auto& op: inst.getDestOperands()) {
                    regState.regStateUpdate(op.getRecord());
                }
                filter.appendFilteredPTE(inst);
                continue;
            }

            if (config.endInst && (inst.index() > config.endInst)) {
                break;
            }

            const auto block_type = kernel_tracer.GetInstType(inst.index());

            switch (block_type) {
                case stf::KernelCodeTracer::ExecBlock::BlockType::USER:
                    instFiltered = false;
                    break;

                case stf::KernelCodeTracer::ExecBlock::BlockType::KERN_SVC:
                    instFiltered = config.filterSyscalls;
                    break;

                case stf::KernelCodeTracer::ExecBlock::BlockType::USER_DUPLICATE:
                case stf::KernelCodeTracer::ExecBlock::BlockType::KERN_OTHER:
                case stf::KernelCodeTracer::ExecBlock::BlockType::KERN_UNKNOWN:
                    instFiltered = config.filterKernel;
                    break;

                default:
                    break;
            }


            // If inst is not being filtered due to being kernel code, still
            // need to check if it needs filtering due to duplication
            if (!instFiltered) {
                // check if there is an event
                bool is_fault = false;
                bool found_event = false;
                uint32_t event_num = 0;
                for(const auto& evt: inst.getEvents()) {
                    const auto event = static_cast<uint32_t>(evt.getEvent());
                    if (evt.isFault()) {
                        is_fault = true;
                        event_num = event;
                        break;
                    }
                    if (config.eset.find(event) != config.eset.end()) {
                        // instr with event
                        found_event = true;
                        event_num = event;
                        break;
                    }
                }

                if(is_fault) {
                    if(config.filterKernel) {
                        // if async interrupt is tagged, keep the instruction, remove event;
                        evtFiltered = true;
                        if (config.verbose) {
                            std::cerr << "Removing event ";
                            stf::format_utils::formatHex(std::cerr, event_num);
                            std::cerr << ": " << inst.index() << ", " << stf_writer.numInstsWritten() + 1 << std::endl;
                        }
                    }
                }
                else if(found_event) {
                    if(inst.isSyscall()) {
                        if (config.filterSyscalls) {
                            // if SVC, keep inst, filter EVT
                            evtFiltered = true;
                        }
                    } else if (filter.getDecoder().decode(inst.opcode()).isBranch()) {
                        if (config.filterKernel) {
                            // branching to new instruction page that causes page fault
                            // keep instruction, throw away event
                            // the next instruction will be aborted since we don't have the instruction data, but the branch did occur
                            evtFiltered = true;
                            if (config.verbose) {
                                std::cerr << "Faulting branch: " << inst.index() << ", " << stf_writer.numInstsWritten() + 1 << std::endl;
                            }
                        }

                    } else {
                        if (config.filterKernel) {
                            // other events such as, data abort, instr abort etc;
                            // a duplicate instruction will be executed after kernel exception handler,
                            // so don't write this inst
                            instFiltered = true;
                            if (config.verbose) {
                                std::cerr << "OtherEvent_";
                                stf::format_utils::formatHex(std::cerr, event_num);
                                std::cerr << ": " << inst.index() << ", " << stf_writer.numInstsWritten() + 1 << std::endl;
                            }
                        }
                    }
                }
            }


            if (instFiltered) {
                // the instruction is filtered; update register state;
                for(const auto& op: inst.getDestOperands()) {
                    regState.regStateUpdate(op.getRecord());
                }
                // the instruction is filtered; PTE;
                filter.appendFilteredPTE(inst);

            } else {
                // If the initial register state has not been written yet,
                // write it
                if (!reg_state_written) {
                    reg_state_written = true;
                    regState.writeRegState(stf_writer);

                }
                filter.writeInst(stf_writer, inst, !evtFiltered, regState, config.verbose);
            }
        }

        if (stf_writer) {
            filter.writeLastInst(stf_writer, !evtFiltered);
            stf_writer.close();
        }
    }
    catch(const trace_tools::CommandLineParser::EarlyExitException& e) {
        std::cerr << e.what() << std::endl;
        return e.getCode();
    }

    return 0;
}
